use serde::Deserialize;
use std::{fs, path::Path};

fn main() {
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();
    let manifest_path = Path::new(&manifest_dir);

    // --- Paradigm includes (Phase 3) ---
    let paradigm_dir = manifest_path.join("src/paradigms/defs");
    let includes = scan_paradigm_includes(&paradigm_dir);
    fs::write(
        format!("{out_dir}/paradigm_includes.rs"),
        format!("&[\n{}\n]", includes.join(",\n")),
    )
    .unwrap();

    // Watch directory so new TOML files trigger rebuild
    println!("cargo:rerun-if-changed=src/paradigms/defs");

    // --- Language registry (Phase 6) ---
    let lang_dir = manifest_path.join("src/languages/defs");
    let lang_defs = scan_language_defs(&lang_dir);
    let registry_code = generate_lang_registry(&lang_defs);
    fs::write(format!("{out_dir}/lang_registry.rs"), registry_code).unwrap();

    // Watch directory so new TOML files trigger rebuild
    println!("cargo:rerun-if-changed=src/languages/defs");
}

fn scan_paradigm_includes(dir: &Path) -> Vec<String> {
    let mut includes = Vec::new();
    if dir.exists() {
        let mut entries: Vec<_> = fs::read_dir(dir).unwrap().flatten().collect();
        entries.sort_by_key(|e| e.file_name()); // deterministic order
        for entry in entries {
            if entry.path().extension().is_some_and(|e| e == "toml") {
                // Use absolute path for include_str! since the generated file is in OUT_DIR
                let abs = entry.path().canonicalize().unwrap_or_else(|_| entry.path());
                includes.push(format!("    include_str!(\"{}\")", abs.display()));
                println!("cargo:rerun-if-changed={}", entry.path().display());
            }
        }
    }
    includes
}

// ---------------------------------------------------------------------------
// Language TOML schema (parsed at build time)
// ---------------------------------------------------------------------------

#[derive(Deserialize)]
struct LangToml {
    #[allow(dead_code)]
    schema_version: u32,
    name: String,
    extensions: Vec<String>,
    glob: String,
    grammar: GrammarSection,
    builtin: Option<BuiltinSection>,
}

#[derive(Deserialize)]
struct GrammarSection {
    crate_path: String,
    #[serde(default)]
    aliases: Vec<GrammarAlias>,
}

#[derive(Deserialize)]
struct GrammarAlias {
    name: String,
    crate_path: String,
    for_extensions: Vec<String>,
    /// When true, this alias is auto-added to expanded language lists.
    /// E.g., "typescript" → "tsx" ensures paradigm queries compile for .tsx files.
    #[serde(default)]
    expand: bool,
}

#[derive(Deserialize)]
struct BuiltinSection {
    entity_extractor: Option<String>,
    dep_extractor: Option<String>,
}

// ---------------------------------------------------------------------------
// Language TOML scanner
// ---------------------------------------------------------------------------

fn scan_language_defs(dir: &Path) -> Vec<LangToml> {
    let mut defs = Vec::new();
    if !dir.exists() {
        return defs;
    }
    let mut entries: Vec<_> = fs::read_dir(dir).unwrap().flatten().collect();
    entries.sort_by_key(|e| e.file_name()); // deterministic order
    for entry in entries {
        if entry.path().extension().is_some_and(|e| e == "toml") {
            println!("cargo:rerun-if-changed={}", entry.path().display());
            let content = fs::read_to_string(entry.path()).unwrap_or_else(|e| {
                panic!(
                    "failed to read language def {}: {}",
                    entry.path().display(),
                    e
                )
            });
            let def: LangToml = toml::from_str(&content).unwrap_or_else(|e| {
                panic!(
                    "failed to parse language def {}: {}",
                    entry.path().display(),
                    e
                )
            });
            defs.push(def);
        }
    }
    defs
}

// ---------------------------------------------------------------------------
// Code generation
// ---------------------------------------------------------------------------

fn generate_lang_registry(defs: &[LangToml]) -> String {
    let mut code = String::new();

    // Header
    code.push_str("// AUTO-GENERATED by build.rs from languages/defs/*.toml — DO NOT EDIT\n\n");

    // --- LangId struct ---
    code.push_str(
        "/// Opaque language identifier backed by a static registry.\n\
         #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n\
         pub struct LangId(u16);\n\n",
    );

    // Debug impl
    code.push_str(
        "impl std::fmt::Debug for LangId {\n\
         \x20   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n\
         \x20       write!(f, \"LangId({})\", self.name())\n\
         \x20   }\n\
         }\n\n",
    );

    // --- Constants ---
    code.push_str("impl LangId {\n");
    for (i, def) in defs.iter().enumerate() {
        let const_name = def.name.to_uppercase();
        code.push_str(&format!(
            "    pub const {}: LangId = LangId({});\n",
            const_name, i
        ));
    }
    code.push('\n');

    // count()
    code.push_str(&format!(
        "    /// Total number of registered languages.\n\
         \x20   pub const fn count() -> usize {{ {} }}\n\n",
        defs.len()
    ));

    // name()
    code.push_str(
        "    /// Display name.\n\
         \x20   pub fn name(self) -> &'static str {\n\
         \x20       match self.0 {\n",
    );
    for (i, def) in defs.iter().enumerate() {
        code.push_str(&format!("            {} => \"{}\",\n", i, def.name));
    }
    code.push_str(
        "            _ => \"unknown\",\n\
         \x20       }\n\
         \x20   }\n\n",
    );

    // glob_pattern()
    code.push_str(
        "    /// Get source file glob pattern for this language.\n\
         \x20   pub fn glob_pattern(self) -> &'static str {\n\
         \x20       match self.0 {\n",
    );
    for (i, def) in defs.iter().enumerate() {
        code.push_str(&format!("            {} => \"{}\",\n", i, def.glob));
    }
    code.push_str(
        "            _ => \"**/*\",\n\
         \x20       }\n\
         \x20   }\n\n",
    );

    // ts_language()
    code.push_str(
        "    /// Get the tree-sitter Language for parsing.\n\
         \x20   pub fn ts_language(self) -> tree_sitter::Language {\n\
         \x20       match self.0 {\n",
    );
    for (i, def) in defs.iter().enumerate() {
        code.push_str(&format!(
            "            {} => {}.into(),\n",
            i, def.grammar.crate_path
        ));
    }
    code.push_str(
        "            _ => panic!(\"invalid LangId\"),\n\
         \x20       }\n\
         \x20   }\n\n",
    );

    // from_extension()
    code.push_str(
        "    /// Detect language from file extension.\n\
         \x20   pub fn from_extension(ext: &str) -> Option<Self> {\n\
         \x20       match ext {\n",
    );
    for (i, def) in defs.iter().enumerate() {
        let patterns: Vec<String> = def
            .extensions
            .iter()
            .map(|e| format!("\"{}\"", e))
            .collect();
        code.push_str(&format!(
            "            {} => Some(LangId({})),\n",
            patterns.join(" | "),
            i,
        ));
    }
    code.push_str(
        "            _ => None,\n\
         \x20       }\n\
         \x20   }\n\n",
    );

    // from_name()
    code.push_str(
        "    /// Parse language from name string.\n\
         \x20   pub fn from_name(name: &str) -> Option<Self> {\n\
         \x20       match name {\n",
    );
    for (i, def) in defs.iter().enumerate() {
        code.push_str(&format!(
            "            \"{}\" => Some(LangId({})),\n",
            def.name, i,
        ));
    }
    code.push_str(
        "            _ => None,\n\
         \x20       }\n\
         \x20   }\n\n",
    );

    // index()
    code.push_str(
        "    /// Get the numeric index (used for count arrays).\n\
         \x20   pub fn index(self) -> usize {\n\
         \x20       self.0 as usize\n\
         \x20   }\n\n",
    );

    // from_index()
    code.push_str(
        "    /// Create from numeric index.\n\
         \x20   fn from_index(idx: usize) -> Self {\n\
         \x20       debug_assert!(idx < Self::count(), \"LangId index out of bounds\");\n\
         \x20       LangId(idx as u16)\n\
         \x20   }\n\n",
    );

    // detect_primary() / detect_all() / count_files()
    code.push_str(
        "    /// Detect the primary language of a project by counting file extensions.\n\
         \x20   pub fn detect_primary(root: &std::path::Path) -> Option<Self> {\n\
         \x20       let counts = Self::count_files(root);\n\
         \x20       let max_idx = counts.iter().enumerate().max_by_key(|(_, count)| **count)?.0;\n\
         \x20       if counts[max_idx] == 0 {\n\
         \x20           return None;\n\
         \x20       }\n\
         \x20       Some(Self::from_index(max_idx))\n\
         \x20   }\n\n\
         \x20   /// Detect all languages present in a project (ordered by file count, descending).\n\
         \x20   pub fn detect_all(root: &std::path::Path) -> Vec<Self> {\n\
         \x20       let counts = Self::count_files(root);\n\
         \x20       let mut langs: Vec<(Self, usize)> = counts\n\
         \x20           .iter()\n\
         \x20           .enumerate()\n\
         \x20           .filter(|(_, count)| **count > 0)\n\
         \x20           .map(|(idx, count)| (Self::from_index(idx), *count))\n\
         \x20           .collect();\n\
         \x20       langs.sort_by(|a, b| b.1.cmp(&a.1));\n\
         \x20       langs.into_iter().map(|(lang, _)| lang).collect()\n\
         \x20   }\n\n\
         \x20   /// Count files per language in the project.\n\
         \x20   fn count_files(root: &std::path::Path) -> Vec<usize> {\n\
         \x20       let mut counts = vec![0usize; Self::count()];\n\
         \x20       let walker = ignore::WalkBuilder::new(root)\n\
         \x20           .hidden(true)\n\
         \x20           .git_ignore(true)\n\
         \x20           .add_custom_ignore_filename(\".rpgignore\")\n\
         \x20           .build();\n\
         \x20       for entry in walker.flatten() {\n\
         \x20           if let Some(ext) = entry.path().extension().and_then(|e| e.to_str())\n\
         \x20               && let Some(lang) = Self::from_extension(ext)\n\
         \x20           {\n\
         \x20               counts[lang.index()] += 1;\n\
         \x20           }\n\
         \x20       }\n\
         \x20       counts\n\
         \x20   }\n",
    );

    // Close impl LangId
    code.push_str("}\n\n");

    // --- Backward-compat alias ---
    code.push_str("/// Backward-compatibility alias.\npub type Language = LangId;\n\n");

    // --- grammar_for() function (replaces ts_language_for in query_engine) ---
    code.push_str(
        "/// Map language/grammar name to tree-sitter Language.\n\
         /// Handles both language names and grammar alias names (e.g., \"tsx\").\n\
         pub fn grammar_for(name: &str) -> Option<tree_sitter::Language> {\n\
         \x20   match name {\n",
    );
    // Primary language names
    for def in defs {
        code.push_str(&format!(
            "        \"{}\" => Some({}.into()),\n",
            def.name, def.grammar.crate_path,
        ));
        // Grammar aliases
        for alias in &def.grammar.aliases {
            code.push_str(&format!(
                "        \"{}\" => Some({}.into()),\n",
                alias.name, alias.crate_path,
            ));
        }
    }
    code.push_str("        _ => None,\n    }\n}\n\n");

    // --- expand_lang_aliases() function (replaces expand_languages) ---
    code.push_str(
        "/// Expand language lists with grammar aliases.\n\
         /// E.g., \"typescript\" implies \"tsx\" (superset grammar for .tsx files).\n\
         pub fn expand_lang_aliases(languages: &[String]) -> Vec<String> {\n\
         \x20   let mut expanded = languages.to_vec();\n",
    );
    // For each language with expandable aliases, check if it's present and add alias names
    for def in defs {
        for alias in &def.grammar.aliases {
            if alias.expand {
                code.push_str(&format!(
                    "    if expanded.iter().any(|l| l == \"{}\") && !expanded.iter().any(|l| l == \"{}\") {{\n\
                     \x20       expanded.push(\"{}\".to_string());\n\
                     \x20   }}\n",
                    def.name, alias.name, alias.name,
                ));
            }
        }
    }
    code.push_str("    expanded\n}\n\n");

    // --- effective_grammar_name() function (replaces effective_lang_name) ---
    code.push_str(
        "/// For languages with grammar aliases, determine which grammar to use\n\
         /// based on the file extension. E.g., TypeScript .tsx files use \"tsx\" grammar.\n\
         pub fn effective_grammar_name<'a>(lang_name: &'a str, file_ext: &str) -> &'a str {\n\
         \x20   match lang_name {\n",
    );
    for def in defs {
        if !def.grammar.aliases.is_empty() {
            code.push_str(&format!("        \"{}\" => match file_ext {{\n", def.name,));
            for alias in &def.grammar.aliases {
                let ext_patterns: Vec<String> = alias
                    .for_extensions
                    .iter()
                    .map(|e| format!("\"{}\"", e))
                    .collect();
                code.push_str(&format!(
                    "            {} => \"{}\",\n",
                    ext_patterns.join(" | "),
                    alias.name,
                ));
            }
            code.push_str(&format!(
                "            _ => \"{}\",\n\
                 \x20       }},\n",
                def.name,
            ));
        }
    }
    code.push_str(
        "        other => other,\n\
         \x20   }\n\
         }\n\n",
    );

    // --- builtin_entity_extractor() function ---
    code.push_str(
        "/// Look up a builtin entity extractor function by name.\n\
         pub fn builtin_entity_extractor(\n\
         \x20   name: &str,\n\
         ) -> Option<fn(&std::path::Path, &str) -> Vec<crate::entities::RawEntity>> {\n\
         \x20   match name {\n",
    );
    for def in defs {
        if let Some(ref builtin) = def.builtin
            && let Some(ref extractor) = builtin.entity_extractor
        {
            code.push_str(&format!(
                "        \"{}\" => Some(crate::entities::{}),\n",
                extractor, extractor,
            ));
        }
    }
    code.push_str("        _ => None,\n    }\n}\n\n");

    // --- builtin_dep_extractor_name() — returns the name so dispatch can happen in deps.rs ---
    code.push_str(
        "/// Look up the builtin dep extractor name for a language.\n\
         pub fn builtin_dep_extractor_name(lang: LangId) -> Option<&'static str> {\n\
         \x20   match lang.0 {\n",
    );
    for (i, def) in defs.iter().enumerate() {
        if let Some(ref builtin) = def.builtin
            && let Some(ref extractor) = builtin.dep_extractor
        {
            code.push_str(&format!("        {} => Some(\"{}\"),\n", i, extractor,));
        }
    }
    code.push_str("        _ => None,\n    }\n}\n\n");

    // --- entity_extractor_name() — returns the name for a language ---
    code.push_str(
        "/// Look up the builtin entity extractor name for a language.\n\
         pub fn builtin_entity_extractor_name(lang: LangId) -> Option<&'static str> {\n\
         \x20   match lang.0 {\n",
    );
    for (i, def) in defs.iter().enumerate() {
        if let Some(ref builtin) = def.builtin
            && let Some(ref extractor) = builtin.entity_extractor
        {
            code.push_str(&format!("        {} => Some(\"{}\"),\n", i, extractor,));
        }
    }
    code.push_str("        _ => None,\n    }\n}\n");

    code
}
